#!/usr/bin/env node

/**
 * Security Audit Script
 * Run automated security checks on the codebase
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

const CHECKS: Record<string, string> = {
  PASSED: 'âœ“',
  FAILED: 'âœ—',
  WARNING: 'âš ',
};

type AuditResult = { check: string; status: string; message: string };
const results: AuditResult[] = [];

function log(check: string, status: string, message: string): void {
  results.push({ check, status, message });
  console.log(${CHECKS[status]} : );
}

function runCheck(name: string, fn: () => void): void {
  try {
    console.log(\nðŸ” );
    fn();
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    log(name, 'FAILED', errorMsg);
  }
}

// Check 1: No .env file in git
runCheck('Check: .env not in version control', () => {
  try {
    execSync('git ls-files | grep -E "^\\.env\$"', { stdio: 'pipe' });
    log('ENV_IN_GIT', 'FAILED', '.env file found in git');
  } catch {
    log('ENV_IN_GIT', 'PASSED', '.env is properly ignored');
  }
});

// Check 2: npm audit clean
runCheck('Check: npm dependencies secure', () => {
  const output = execSync('npm audit --json 2>/dev/null || echo "{}"', { encoding: 'utf8' });
  try {
    const audit = JSON.parse(output);
    if (audit.metadata?.vulnerabilities?.total > 0) {
      log('NPM_AUDIT', 'FAILED', \ vulnerabilities found);
    } else {
      log('NPM_AUDIT', 'PASSED', 'No vulnerabilities found');
    }
  } catch {
    log('NPM_AUDIT', 'PASSED', 'npm audit completed');
  }
});

// Check 3: next.config.ts security headers
runCheck('Check: Security headers configured', () => {
  const configPath = path.join(process.cwd(), 'next.config.ts');
  if (!fs.existsSync(configPath)) {
    log('SECURITY_HEADERS', 'FAILED', 'next.config.ts not found');
    return;
  }

  const content = fs.readFileSync(configPath, 'utf8');
  const hasHeaders = content.includes('X-Content-Type-Options') &&
                     content.includes('X-Frame-Options') &&
                     content.includes('Strict-Transport-Security');

  if (hasHeaders) {
    log('SECURITY_HEADERS', 'PASSED', 'All security headers configured');
  } else {
    log('SECURITY_HEADERS', 'WARNING', 'Some security headers may be missing');
  }
});

// Check 4: Middleware files exist
runCheck('Check: Security middleware installed', () => {
  const files = [
    'lib/middleware/rateLimit.ts',
    'lib/middleware/cors.ts',
    'lib/config/env.ts',
  ];

  const missing = files.filter(f => !fs.existsSync(path.join(process.cwd(), f)));
  if (missing.length > 0) {
    log('MIDDLEWARE', 'WARNING', Missing files: \);
  } else {
    log('MIDDLEWARE', 'PASSED', 'All security middleware present');
  }
});

// Check 5: .env.example exists
runCheck('Check: Environment template present', () => {
  if (fs.existsSync(path.join(process.cwd(), '.env.example'))) {
    log('ENV_EXAMPLE', 'PASSED', '.env.example found');
  } else {
    log('ENV_EXAMPLE', 'FAILED', '.env.example not found');
  }
});

// Check 6: SECURITY.md exists
runCheck('Check: Security policy documented', () => {
  if (fs.existsSync(path.join(process.cwd(), 'SECURITY.md'))) {
    log('SECURITY_MD', 'PASSED', 'SECURITY.md present');
  } else {
    log('SECURITY_MD', 'WARNING', 'SECURITY.md not found');
  }
});

// Summary
console.log('\n' + '='.repeat(50));
console.log('SECURITY AUDIT SUMMARY');
console.log('='.repeat(50));

const passed = results.filter(r => r.status === 'PASSED').length;
const failed = results.filter(r => r.status === 'FAILED').length;
const warnings = results.filter(r => r.status === 'WARNING').length;

console.log(\nPassed: \);
console.log(Failed: \);
console.log(Warnings: \);

if (failed > 0) {
  console.log('\nSecurity audit FAILED - please fix the issues above');
  process.exit(1);
}

if (warnings > 0) {
  console.log('\nSecurity audit passed with warnings');
  process.exit(0);
}

console.log('\nSecurity audit PASSED');
process.exit(0);
