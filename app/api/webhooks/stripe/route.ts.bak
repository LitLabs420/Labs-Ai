import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { supabase } from '@/lib/supabase';
import { captureError } from '@/lib/sentry';
import { auditLog, addSecurityHeaders } from '@/lib/security-utils';

// Initialize Stripe with secret key
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '');

// Webhook secret for signature verification (CRITICAL - must be set)
const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET || '';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';
export const maxDuration = 60;

export async function POST(request: NextRequest) {
  let response: NextResponse;

  try {
    // Validate webhook secret is configured
    if (!webhookSecret) {
      captureError("CRITICAL: Stripe webhook secret not configured", {
        error: "Missing STRIPE_WEBHOOK_SECRET environment variable",
      });
      response = NextResponse.json(
        { error: 'Webhook configuration error' },
        { status: 500 }
      );
      return addSecurityHeaders(response);
    }

    // Get the raw body for signature verification
    const body = await request.text();
    const signature = request.headers.get('stripe-signature') || '';

    // Verify the webhook signature (CRITICAL - prevent spoofing)
    let event: Stripe.Event;
    try {
      event = stripe.webhooks.constructEvent(body, signature, webhookSecret);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      // Log security event but don't expose details to client
      captureError('Stripe webhook signature verification failed', {
        error: errorMessage,
        ip: request.headers.get('x-forwarded-for'),
      });
      response = NextResponse.json(
        { error: 'Invalid webhook signature' },
        { status: 403 }
      );
      return addSecurityHeaders(response);
    }

    // Log webhook receipt (security audit)
    await auditLog(
      'stripe-system',
      'webhook_received',
      `stripe:${event.type}`,
      { eventId: event.id, timestamp: event.created },
      'low'
    );

    // Handle different event types
    switch (event.type) {
      case 'payment_intent.succeeded':
        await handlePaymentIntentSucceeded(event.data.object as Stripe.PaymentIntent);
        break;

      case 'payment_intent.payment_failed':
        await handlePaymentIntentFailed(event.data.object as Stripe.PaymentIntent);
        break;

      case 'charge.refunded':
        await handleChargeRefunded(event.data.object as Stripe.Charge);
        break;

      case 'customer.subscription.created':
        await handleSubscriptionCreated(event.data.object as Stripe.Subscription);
        break;

      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;

      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;

      case 'invoice.payment_succeeded':
        await handleInvoicePaymentSucceeded(event.data.object as Stripe.Invoice);
        break;

      case 'invoice.payment_failed':
        await handleInvoicePaymentFailed(event.data.object as Stripe.Invoice);
        break;

      // Silently ignore unhandled event types
      default:
        break;
    }

    // Always return 200 OK to acknowledge receipt (prevents Stripe retries)
    response = NextResponse.json({ received: true });
    return addSecurityHeaders(response);
  } catch (error: unknown) {
    // Log error securely
    captureError('Stripe webhook processing error', {
      error: error instanceof Error ? error.message : String(error),
      path: request.nextUrl.pathname,
    });

    // Return generic error response (never expose internal details)
    response = NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 500 }
    );
    return addSecurityHeaders(response);
  }
}

// Event Handlers

async function handlePaymentIntentSucceeded(paymentIntent: Stripe.PaymentIntent) {
  try {
    // Log business event (not implementation details)
    await auditLog(
      paymentIntent.metadata?.userId || 'unknown',
      'payment_succeeded',
      `stripe:payment:${paymentIntent.id}`,
      { amount: paymentIntent.amount / 100, currency: paymentIntent.currency },
      'medium'
    );

    if (!paymentIntent.metadata?.userId) {
      captureError('Payment succeeded without userId', { paymentId: paymentIntent.id });
      return;
    }

    // Save payment record to database
    const { error } = await supabase.from('payments').insert({
      stripe_payment_id: paymentIntent.id,
      user_id: paymentIntent.metadata.userId,
      amount: Math.round(paymentIntent.amount),
      currency: paymentIntent.currency.toUpperCase(),
      status: 'succeeded',
      created_at: new Date(paymentIntent.created * 1000).toISOString(),
    });

    if (error) {
      captureError('Failed to save payment record', { error, paymentId: paymentIntent.id });
    }
  } catch (error: unknown) {
    captureError('Error handling payment success', {
      error: error instanceof Error ? error.message : String(error),
      paymentId: paymentIntent.id,
    });
  }
}

async function handlePaymentIntentFailed(paymentIntent: Stripe.PaymentIntent) {
  try {
    if (!paymentIntent.metadata?.userId) {
      captureError('Payment failed without userId', { paymentId: paymentIntent.id });
      return;
    }

    // Log business event
    await auditLog(
      paymentIntent.metadata.userId,
      'payment_failed',
      `stripe:payment:${paymentIntent.id}`,
      { amount: paymentIntent.amount / 100, error: paymentIntent.last_payment_error?.message },
      'high'
    );

    // Save failed payment record
    const { error } = await supabase.from('payment_failures').insert({
      stripe_payment_id: paymentIntent.id,
      user_id: paymentIntent.metadata.userId,
      amount: Math.round(paymentIntent.amount),
      currency: paymentIntent.currency.toUpperCase(),
      error_message: paymentIntent.last_payment_error?.message || 'Unknown error',
      created_at: new Date(paymentIntent.created * 1000).toISOString(),
    });

    if (error) {
      captureError('Failed to log payment failure', { error, paymentId: paymentIntent.id });
      return;
    }

    // Send email notification (non-blocking)
    sendFailedPaymentEmail(paymentIntent.metadata.userId, {
      amount: paymentIntent.amount / 100,
      currency: paymentIntent.currency,
      paymentId: paymentIntent.id,
      error: paymentIntent.last_payment_error?.message,
    }).catch((err) => {
      captureError('Failed to send payment failure email', { error: err });
    });
  } catch (error: unknown) {
    captureError('Error handling payment failure', {
      error: error instanceof Error ? error.message : String(error),
      paymentId: paymentIntent.id,
    });
  }
}

async function handleChargeRefunded(charge: Stripe.Charge) {
  try {
    // Log business event
    await auditLog(
      'stripe-system',
      'charge_refunded',
      `stripe:charge:${charge.id}`,
      { amount: charge.amount_refunded / 100, currency: charge.currency },
      'medium'
    );

    // Save refund record
    const { error } = await supabase.from('refunds').insert({
      stripe_charge_id: charge.id,
      amount: charge.amount_refunded,
      currency: charge.currency.toUpperCase(),
      created_at: new Date((charge.created || 0) * 1000).toISOString(),
    });

    if (error) {
      captureError('Failed to save refund record', { error, chargeId: charge.id });
    }
  } catch (error: unknown) {
    captureError('Error handling refund', {
      error: error instanceof Error ? error.message : String(error),
      chargeId: charge.id,
    });
  }
}

async function handleSubscriptionCreated(subscription: Stripe.Subscription) {
  try {
    if (!subscription.metadata?.userId) {
      captureError('Subscription created without userId', { subscriptionId: subscription.id });
      return;
    }

    // Log business event
    await auditLog(
      subscription.metadata.userId,
      'subscription_created',
      `stripe:subscription:${subscription.id}`,
      { status: subscription.status },
      'medium'
    );

    // Save subscription
    const { error } = await supabase.from('subscriptions').insert({
      stripe_subscription_id: subscription.id,
      user_id: subscription.metadata.userId,
      stripe_customer_id: subscription.customer as string,
      status: subscription.status,
      current_period_end: new Date(((subscription as any).current_period_end || 0) * 1000).toISOString(),
      created_at: new Date((subscription.created || 0) * 1000).toISOString(),
    });

    if (error) {
      captureError('Failed to save subscription', { error, subscriptionId: subscription.id });
    }
  } catch (error: unknown) {
    captureError('Error handling subscription creation', {
      error: error instanceof Error ? error.message : String(error),
      subscriptionId: subscription.id,
    });
  }
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  try {
    if (!subscription.metadata?.userId) {
      captureError('Subscription updated without userId', { subscriptionId: subscription.id });
      return;
    }

    // Log business event
    await auditLog(
      subscription.metadata.userId,
      'subscription_updated',
      `stripe:subscription:${subscription.id}`,
      { status: subscription.status },
      'low'
    );

    // Update subscription in database
    const { error } = await supabase
      .from('subscriptions')
      .update({
        status: subscription.status,
        current_period_end: new Date(((subscription as any).current_period_end || 0) * 1000).toISOString(),
        updated_at: new Date().toISOString(),
      })
      .eq('stripe_subscription_id', subscription.id);

    if (error) {
      captureError('Failed to update subscription', { error, subscriptionId: subscription.id });
    }
  } catch (error: unknown) {
    captureError('Error handling subscription update', {
      error: error instanceof Error ? error.message : String(error),
      subscriptionId: subscription.id,
    });
  }
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  try {
    if (!subscription.metadata?.userId) {
      captureError('Subscription deleted without userId', { subscriptionId: subscription.id });
      return;
    }

    // Log business event (HIGH priority)
    await auditLog(
      subscription.metadata.userId,
      'subscription_cancelled',
      `stripe:subscription:${subscription.id}`,
      { status: subscription.status, canceled_at: subscription.canceled_at },
      'high'
    );

    // Update subscription status
    const { error } = await supabase
      .from('subscriptions')
      .update({
        status: 'cancelled',
        canceled_at: new Date((subscription.canceled_at || 0) * 1000).toISOString(),
        updated_at: new Date().toISOString(),
      })
      .eq('stripe_subscription_id', subscription.id);

    if (error) {
      captureError('Failed to cancel subscription', { error, subscriptionId: subscription.id });
      return;
    }

    // Send cancellation email (non-blocking)
    sendCancellationEmail(subscription.metadata.userId, subscription.id).catch((err) => {
      captureError('Failed to send cancellation email', { error: err });
    });
  } catch (error: unknown) {
    captureError('Error handling subscription deletion', {
      error: error instanceof Error ? error.message : String(error),
      subscriptionId: subscription.id,
    });
  }
}

async function handleInvoicePaymentSucceeded(invoice: Stripe.Invoice) {
  try {
    if (!invoice.customer) {
      captureError('Invoice paid without customer', { invoiceId: invoice.id });
      return;
    }

    // Log business event
    await auditLog(
      'stripe-system',
      'invoice_paid',
      `stripe:invoice:${invoice.id}`,
      { amount: invoice.amount_paid / 100, currency: invoice.currency },
      'medium'
    );

    // Save invoice record
    const { error } = await supabase.from('invoices').insert({
      stripe_invoice_id: invoice.id,
      stripe_customer_id: invoice.customer as string,
      amount: invoice.amount_paid,
      currency: invoice.currency?.toUpperCase(),
      status: 'paid',
      created_at: new Date((invoice.created || 0) * 1000).toISOString(),
    });

    if (error) {
      captureError('Failed to save invoice', { error, invoiceId: invoice.id });
    }
  } catch (error: unknown) {
    captureError('Error handling invoice payment success', {
      error: error instanceof Error ? error.message : String(error),
      invoiceId: invoice.id,
    });
  }
}

async function handleInvoicePaymentFailed(invoice: Stripe.Invoice) {
  try {
    if (!invoice.customer) {
      captureError('Invoice payment failed without customer', { invoiceId: invoice.id });
      return;
    }

    // Log business event (HIGH priority)
    await auditLog(
      'stripe-system',
      'invoice_payment_failed',
      `stripe:invoice:${invoice.id}`,
      { amount: invoice.amount_due / 100, currency: invoice.currency },
      'high'
    );

    // Save failed invoice record
    const { error } = await supabase.from('invoice_failures').insert({
      stripe_invoice_id: invoice.id,
      stripe_customer_id: invoice.customer as string,
      amount: invoice.amount_due,
      currency: invoice.currency?.toUpperCase(),
      created_at: new Date((invoice.created || 0) * 1000).toISOString(),
    });

    if (error) {
      captureError('Failed to log invoice failure', { error, invoiceId: invoice.id });
      return;
    }

    // Send failure email (non-blocking)
    sendInvoiceFailureEmail(invoice.customer as string, {
      invoiceId: invoice.id,
      amount: invoice.amount_due / 100,
      currency: invoice.currency,
    }).catch((err) => {
      captureError('Failed to send invoice failure email', { error: err });
    });
  } catch (error: unknown) {
    captureError('Error handling invoice payment failure', {
      error: error instanceof Error ? error.message : String(error),
      invoiceId: invoice.id,
    });
  }
}

// Helper Functions (Non-blocking Email Sending)

async function sendFailedPaymentEmail(
  userId: string,
  details: { amount: number; currency: string; paymentId: string; error?: string }
) {
  try {
    await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/email/send`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId,
        subject: 'Payment Failed - LitLabs',
        template: 'payment_failed',
        data: {
          amount: details.amount.toFixed(2),
          currency: details.currency,
          paymentId: details.paymentId,
          error: details.error,
        },
      }),
    });
  } catch (error: unknown) {
    throw new Error(`Failed to send payment failed email: ${error instanceof Error ? error.message : String(error)}`);
  }
}

async function sendCancellationEmail(userId: string, subscriptionId: string) {
  try {
    await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/email/send`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId,
        subject: 'Subscription Cancelled - LitLabs',
        template: 'subscription_cancelled',
        data: {
          subscriptionId,
          cancelledAt: new Date().toLocaleDateString(),
        },
      }),
    });
  } catch (error: unknown) {
    throw new Error(`Failed to send cancellation email: ${error instanceof Error ? error.message : String(error)}`);
  }
}

async function sendInvoiceFailureEmail(
  customerId: string,
  details: { invoiceId: string; amount: number; currency?: string }
) {
  try {
    await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/email/send`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        customerId,
        subject: 'Invoice Payment Failed - LitLabs',
        template: 'invoice_failed',
        data: {
          invoiceId: details.invoiceId,
          amount: details.amount.toFixed(2),
          currency: details.currency,
          retryDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toLocaleDateString(),
        },
      }),
    });
  } catch (error: unknown) {
    throw new Error(`Failed to send invoice failure email: ${error instanceof Error ? error.message : String(error)}`);
  }
}
